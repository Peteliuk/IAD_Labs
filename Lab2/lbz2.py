'''
масив "вхідні дані":
голосні букви - 1, решту - 0
3(три) масива "Прізвище", 3 масиви "Імя", 3 масиви "ПоБатькові"
в кожній другій і третій копії інвертуєм будь-який один елемент
'''

#Вхідні дані
data = [[0,0,1,0,0,1,0,1,0,0], #Прізвище (Копія 1)
		[0,0,1,1,0,1,0,1,0,0], #Копія 2
		[0,0,1,0,1,1,0,1,0,0], #Копія 3

		[1,0,1,0,0,0,0,0,0,0], #Імя (Копія 1)
		[1,0,1,0,0,0,0,0,1,0], #Копія 2
		[1,0,1,0,0,0,0,0,0,1], #Копія 3

		[0,1,0,1,0,0,0,1,0,1], #ПоБатькові (Копія 1)
		[0,1,0,1,0,0,1,1,0,1], #Копія 2
		[0,1,0,1,0,0,0,1,1,1]] #Копія 3

#Вагові коефіцієнти (ваги)
w_old = [[.09,.12,.32,.31,.45,.92,.56,.04,.81,.34],
         [.39,.34,.67,.08,.35,.22,.76,.64,.01,.45],
         [.58,.68,.75,.14,.18,.14,.24,.43,.57,.65]]

#Для реалізації умови зупину створюєм копію масиву ваг
w_new = [[.09,.12,.32,.31,.45,.92,.56,.04,.81,.34],
         [.39,.34,.67,.08,.35,.22,.76,.64,.01,.45],
         [.58,.68,.75,.14,.18,.14,.24,.43,.57,.65]]

n = .6 #Коефіцієнт швидкості навчання
k = .5 #коефіцієнт оновлення для n
tresshold = .0005 #Порогове значення

steps = 0 #Лічильник кроків
runCycle = True #Запуск циклу
distance_array = [] #Масив відстаней

#функція відстані: приймає 2 масиви (вхідні дані і вагові коефіцієнти)
def distance(x,w):
	sumator = 0
	for i in range(len(data[0])):
		sumator += (w[i] - x[i])**2 #Сума (вагові коефіцієнти - вхідні дані) до квадрату
	return sumator

while runCycle and steps < 100:
	runCycle = False #По дефолту false. Якщо умова не виконається, то true

	for i in data: #і = кожен підмасив в масиві data (вхідні дані)
		#Для кожного вхідного масиву (з нулями та одиницями) шукаєм 3 відстані
		a1 = distance(i, w_new[0])
		a2 = distance(i, w_new[1])
		a3 = distance(i, w_new[2])
		distance_array.append([a1,a2,a3]) #Заносим масив з відстаннями в масив відстаней :)
		for distance_arr in distance_array:
			index = distance_arr.index(min(distance_arr)) #Шукаєм індекс переможця (найменшої відстані)
			for j in range(len(w_new[0])):
				#Оновлюєм вагові
				w_old[index][j] += n*(i[j] - w_old[index][j]) #Оновлюєм старий масив вагових
				w_new[index][j] = w_old[index][j] + n*(i[j] - w_old[index][j]) #Новий масив = оновлений старий + фіча
	steps += 1 #Оновлюєм лічильник кроків
	n *= k #Оновлюєм коефіцієнт швидкості навчання

	'''**************** Stop Condition ************************'''
	''' Якщо різниця по модулю нових вагових і старих <= порогове значення (0.0005) то зупиняєм цикл'''
	for i_stop in range(len(w_new)):
		for j_stop in range(len(w_new[0])):
			if(abs(w_new[i_stop][j_stop] - w_old[i_stop][j_stop]) > tresshold):
				runCycle = True #Якщо умова не справджується то продовжуєм цикл

#Вивід
for i in range(len(data)):
	#Виводим вхідні масиви і їх класи
	#Клас - індекс найменшої відстані + 1 (щоб вивело 1,2,3, а не 0,1,2)
	print(str(data[i]) + "\tКлас: " + str(distance_array[i].index(min(distance_array[i]))+1))
print("Кількість кроків: " + str(steps))